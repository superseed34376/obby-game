<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Obby Game - 12 Stages</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100vh;
        }

        /* UI Overlay */
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            background: rgba(0, 0, 0, 0.5);
            padding: 15px 20px;
            border-radius: 10px;
        }

        #hud div {
            margin: 5px 0;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            background: rgba(0, 0, 0, 0.5);
            padding: 15px 20px;
            border-radius: 10px;
        }

        #winScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px 60px;
            border-radius: 20px;
            text-align: center;
            color: white;
            display: none;
            pointer-events: all;
        }

        #winScreen h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #ffd700;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.8);
        }

        #winScreen p {
            font-size: 24px;
            margin: 10px 0;
        }

        #restartBtn {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 10px;
            color: white;
            cursor: pointer;
            transition: transform 0.2s;
        }

        #restartBtn:hover {
            transform: scale(1.1);
        }

        /* Mobile Controls */
        #mobileControls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: none;
            pointer-events: all;
        }

        .controlBtn {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid white;
            border-radius: 10px;
            color: white;
            font-size: 24px;
            margin: 5px;
            cursor: pointer;
            user-select: none;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .controlBtn:active {
            background: rgba(255, 255, 255, 0.5);
        }

        #dpad {
            display: grid;
            grid-template-columns: repeat(3, 60px);
            gap: 5px;
            margin-bottom: 10px;
        }

        @media (max-width: 768px) {
            #mobileControls {
                display: block;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <div id="hud">
            <div id="stage">Stage: 1/12</div>
            <div id="checkpoint">Checkpoint: Start</div>
            <div id="timer">Time: 0:00</div>
            <div id="deaths">Deaths: 0</div>
        </div>

        <div id="controls">
            <strong>Controls:</strong><br>
            WASD / Arrows - Move<br>
            Space - Jump
        </div>

        <div id="winScreen">
            <h1>üèÜ VICTORY! üèÜ</h1>
            <p id="finalTime">Time: 0:00</p>
            <p id="finalDeaths">Deaths: 0</p>
            <button id="restartBtn">Play Again</button>
        </div>

        <!-- Mobile Controls -->
        <div id="mobileControls">
            <div id="dpad">
                <div></div>
                <div class="controlBtn" data-key="w">‚ñ≤</div>
                <div></div>
                <div class="controlBtn" data-key="a">‚óÑ</div>
                <div class="controlBtn" data-key="s">‚ñº</div>
                <div class="controlBtn" data-key="d">‚ñ∫</div>
            </div>
            <div class="controlBtn" data-key="space" style="width: 130px;">JUMP</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ===== GAME INITIALIZATION =====
        let scene, camera, renderer;
        let player, playerVelocity, playerSpeed, jumpForce, gravity;
        let platforms = [];
        let obstacles = [];
        let currentStage = 1;
        let currentCheckpoint = { x: 0, y: 2, z: 0 };
        let isGrounded = false;
        let gameWon = false;
        let lastJumpTime = 0;
        
        // Input handling
        let keys = {};
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;

        // Game stats
        let startTime = Date.now();
        let deaths = 0;

        // ===== INITIALIZATION =====
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 50, 200);

            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 15);

            // Create renderer
            const canvas = document.getElementById('gameCanvas');
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Create player (humanoid character)
            createPlayer();

            // Initialize player physics
            playerVelocity = new THREE.Vector3(0, 0, 0);
            playerSpeed = 0.15;
            jumpForce = 0.35;
            gravity = -0.02;

            // Create all 12 stages
            createAllStages();

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.getElementById('restartBtn').addEventListener('click', restartGame);

            // Mobile controls
            const controlBtns = document.querySelectorAll('.controlBtn');
            controlBtns.forEach(btn => {
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const key = btn.getAttribute('data-key');
                    keys[key] = true;
                });
                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    const key = btn.getAttribute('data-key');
                    keys[key] = false;
                });
            });

            // Start animation loop
            animate();
        }

        // ===== PLAYER CREATION =====
        function createPlayer() {
            // Create a humanoid character using basic shapes
            player = new THREE.Group();

            // Body
            const bodyGeometry = new THREE.BoxGeometry(0.6, 1, 0.4);
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x3498db });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.5;
            body.castShadow = true;
            player.add(body);

            // Head
            const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const headMaterial = new THREE.MeshPhongMaterial({ color: 0xffdbac });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.3;
            head.castShadow = true;
            player.add(head);

            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const eyeMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.1, 1.35, 0.25);
            player.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.1, 1.35, 0.25);
            player.add(rightEye);

            // Arms
            const armGeometry = new THREE.BoxGeometry(0.2, 0.8, 0.2);
            const armMaterial = new THREE.MeshPhongMaterial({ color: 0xffdbac });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.45, 0.5, 0);
            leftArm.castShadow = true;
            player.add(leftArm);
            player.leftArm = leftArm;
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.45, 0.5, 0);
            rightArm.castShadow = true;
            player.add(rightArm);
            player.rightArm = rightArm;

            // Legs
            const legGeometry = new THREE.BoxGeometry(0.25, 0.9, 0.25);
            const legMaterial = new THREE.MeshPhongMaterial({ color: 0x2c3e50 });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.15, -0.45, 0);
            leftLeg.castShadow = true;
            player.add(leftLeg);
            player.leftLeg = leftLeg;
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.15, -0.45, 0);
            rightLeg.castShadow = true;
            player.add(rightLeg);
            player.rightLeg = rightLeg;

            player.position.set(0, 2, 0);
            scene.add(player);
        }

        // ===== PLAYER ANIMATION =====
        let animationTime = 0;
        
        function animatePlayer() {
            if (!player.leftArm || !player.rightArm || !player.leftLeg || !player.rightLeg) return;

            // Increment animation time based on movement
            const isMoving = moveForward || moveBackward || moveLeft || moveRight;
            if (isMoving && isGrounded) {
                animationTime += 0.15;
            }

            if (isGrounded && isMoving) {
                // Running animation - smooth sine wave for natural movement
                const armSwing = Math.sin(animationTime) * 0.5;
                const legSwing = Math.sin(animationTime) * 0.4;
                
                player.leftArm.rotation.x = armSwing;
                player.leftArm.rotation.y = 0;
                player.leftArm.rotation.z = 0;
                
                player.rightArm.rotation.x = -armSwing;
                player.rightArm.rotation.y = 0;
                player.rightArm.rotation.z = 0;
                
                player.leftLeg.rotation.x = -legSwing;
                player.leftLeg.rotation.y = 0;
                player.leftLeg.rotation.z = 0;
                
                player.rightLeg.rotation.x = legSwing;
                player.rightLeg.rotation.y = 0;
                player.rightLeg.rotation.z = 0;
            } else if (!isGrounded) {
                // Jumping/Falling - arms out, legs slightly bent
                const targetArmRotation = -0.8;
                const targetLegRotation = 0.2;
                
                player.leftArm.rotation.x += (targetArmRotation - player.leftArm.rotation.x) * 0.15;
                player.rightArm.rotation.x += (targetArmRotation - player.rightArm.rotation.x) * 0.15;
                player.leftLeg.rotation.x += (targetLegRotation - player.leftLeg.rotation.x) * 0.15;
                player.rightLeg.rotation.x += (targetLegRotation - player.rightLeg.rotation.x) * 0.15;
                
                // Reset other axes
                player.leftArm.rotation.y = 0;
                player.leftArm.rotation.z = 0;
                player.rightArm.rotation.y = 0;
                player.rightArm.rotation.z = 0;
                player.leftLeg.rotation.y = 0;
                player.leftLeg.rotation.z = 0;
                player.rightLeg.rotation.y = 0;
                player.rightLeg.rotation.z = 0;
            } else {
                // Idle - smooth return to neutral
                player.leftArm.rotation.x += (0 - player.leftArm.rotation.x) * 0.1;
                player.rightArm.rotation.x += (0 - player.rightArm.rotation.x) * 0.1;
                player.leftLeg.rotation.x += (0 - player.leftLeg.rotation.x) * 0.1;
                player.rightLeg.rotation.x += (0 - player.rightLeg.rotation.x) * 0.1;
                
                // Reset other axes
                player.leftArm.rotation.y = 0;
                player.leftArm.rotation.z = 0;
                player.rightArm.rotation.y = 0;
                player.rightArm.rotation.z = 0;
                player.leftLeg.rotation.y = 0;
                player.leftLeg.rotation.z = 0;
                player.rightLeg.rotation.y = 0;
                player.rightLeg.rotation.z = 0;
            }
        }

        // ===== STAGE CREATION =====
        function createAllStages() {
            let zOffset = 0;

            // Stage 1 - Tutorial
            createStage1(zOffset);
            zOffset -= 30;

            // Stage 2 - Small Gaps
            createStage2(zOffset);
            zOffset -= 30;

            // Stage 3 - Moving Platforms
            createStage3(zOffset);
            zOffset -= 35;

            // Stage 4 - Spinning Bars
            createStage4(zOffset);
            zOffset -= 35;

            // Stage 5 - Vertical Jumps
            createStage5(zOffset);
            zOffset -= 40;

            // Stage 6 - Timed Platforms
            createStage6(zOffset);
            zOffset -= 35;

            // Stage 7 - Narrow Walkways
            createStage7(zOffset);
            zOffset -= 35;

            // Stage 8 - Speed Run
            createStage8(zOffset);
            zOffset -= 35;

            // Stage 9 - Bounce Pads
            createStage9(zOffset);
            zOffset -= 40;

            // Stage 10 - Moving Hazards
            createStage10(zOffset);
            zOffset -= 40;

            // Stage 11 - High Difficulty
            createStage11(zOffset);
            zOffset -= 45;

            // Stage 12 - Final Challenge
            createStage12(zOffset);
        }

        function createPlatform(x, y, z, width, height, depth, color = 0x2ecc71) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshPhongMaterial({ color });
            const platform = new THREE.Mesh(geometry, material);
            platform.position.set(x, y, z);
            platform.receiveShadow = true;
            platform.castShadow = true;
            scene.add(platform);
            platforms.push(platform);
            return platform;
        }

        function createCheckpoint(x, y, z, stageNum) {
            // Create a solid platform base for the checkpoint
            const platformGeometry = new THREE.BoxGeometry(2, 0.5, 2);
            const platformMaterial = new THREE.MeshPhongMaterial({ color: 0x27ae60 });
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            platform.position.set(x, y, z);
            platform.receiveShadow = true;
            platform.castShadow = true;
            scene.add(platform);
            platforms.push(platform);
            
            // Add the golden checkpoint marker on top
            const geometry = new THREE.CylinderGeometry(0.8, 0.8, 0.3, 32);
            const material = new THREE.MeshPhongMaterial({ 
                color: 0xffd700,
                emissive: 0xffd700,
                emissiveIntensity: 0.5
            });
            const checkpoint = new THREE.Mesh(geometry, material);
            checkpoint.position.set(x, y + 0.5, z);
            checkpoint.receiveShadow = true;
            scene.add(checkpoint);
            
            // Mark the platform as a checkpoint
            platform.isCheckpoint = true;
            platform.stageNum = stageNum;
            
            return platform;
        }

        // ===== STAGE 1: TUTORIAL =====
        function createStage1(zOffset) {
            createPlatform(0, 0, zOffset, 6, 0.5, 8, 0x27ae60);
            createPlatform(0, 0, zOffset - 10, 6, 0.5, 4, 0x27ae60);
            createPlatform(0, 0, zOffset - 16, 6, 0.5, 4, 0x27ae60);
            createCheckpoint(0, 0.5, zOffset - 22, 2);
        }

        // ===== STAGE 2: SMALL GAPS =====
        function createStage2(zOffset) {
            createPlatform(0, 0, zOffset, 4, 0.5, 3, 0x3498db);
            createPlatform(0, 0, zOffset - 5, 3, 0.5, 3, 0x3498db);
            createPlatform(0, 0.5, zOffset - 9, 3, 0.5, 3, 0x3498db);
            createPlatform(0, 1, zOffset - 13, 4, 0.5, 3, 0x3498db);
            createCheckpoint(0, 1.5, zOffset - 18, 3);
        }

        // ===== STAGE 3: MOVING PLATFORMS =====
        function createStage3(zOffset) {
            createPlatform(0, 0, zOffset, 4, 0.5, 3, 0x9b59b6);
            
            const movingPlatform1 = createPlatform(-3, 0, zOffset - 6, 3, 0.5, 3, 0x8e44ad);
            movingPlatform1.isMoving = true;
            movingPlatform1.moveRange = 6;
            movingPlatform1.moveSpeed = 0.02;
            movingPlatform1.moveAxis = 'x';
            movingPlatform1.startX = -3;

            const movingPlatform2 = createPlatform(3, 0, zOffset - 12, 3, 0.5, 3, 0x8e44ad);
            movingPlatform2.isMoving = true;
            movingPlatform2.moveRange = 6;
            movingPlatform2.moveSpeed = 0.02;
            movingPlatform2.moveAxis = 'x';
            movingPlatform2.startX = 3;

            createPlatform(0, 0, zOffset - 18, 4, 0.5, 3, 0x9b59b6);
            createCheckpoint(0, 0.5, zOffset - 23, 4);
        }

        // ===== STAGE 4: SPINNING BARS =====
        function createStage4(zOffset) {
            createPlatform(0, 0, zOffset, 4, 0.5, 3, 0xe74c3c);

            // Spinning obstacle 1
            const spinner1 = createPlatform(0, 2, zOffset - 6, 8, 0.3, 0.3, 0xc0392b);
            spinner1.isSpinning = true;
            spinner1.spinSpeed = 0.02;
            obstacles.push(spinner1);

            createPlatform(0, 0, zOffset - 6, 3, 0.5, 3, 0xe74c3c);

            // Spinning obstacle 2
            const spinner2 = createPlatform(0, 2, zOffset - 12, 8, 0.3, 0.3, 0xc0392b);
            spinner2.isSpinning = true;
            spinner2.spinSpeed = -0.025;
            obstacles.push(spinner2);

            createPlatform(0, 0, zOffset - 12, 3, 0.5, 3, 0xe74c3c);
            createCheckpoint(0, 0.5, zOffset - 18, 5);
        }

        // ===== STAGE 5: VERTICAL JUMPS =====
        function createStage5(zOffset) {
            createPlatform(0, 0, zOffset, 3, 0.5, 3, 0x1abc9c);
            createPlatform(0, 2, zOffset - 4, 3, 0.5, 3, 0x16a085);
            createPlatform(0, 4, zOffset - 8, 3, 0.5, 3, 0x1abc9c);
            createPlatform(0, 6, zOffset - 12, 3, 0.5, 3, 0x16a085);
            createPlatform(0, 6, zOffset - 16, 4, 0.5, 3, 0x1abc9c);
            createCheckpoint(0, 6.5, zOffset - 20, 6);
        }

        // ===== STAGE 6: TIMED PLATFORMS =====
        function createStage6(zOffset) {
            createPlatform(0, 0, zOffset, 4, 0.5, 3, 0xf39c12);

            const timedPlatform1 = createPlatform(0, 0, zOffset - 5, 3, 0.5, 3, 0xe67e22);
            timedPlatform1.isTimed = true;
            timedPlatform1.visibleDuration = 2000; // 2 seconds visible
            timedPlatform1.invisibleDuration = 2000; // 2 seconds invisible
            timedPlatform1.lastToggle = Date.now();

            const timedPlatform2 = createPlatform(0, 0, zOffset - 10, 3, 0.5, 3, 0xe67e22);
            timedPlatform2.isTimed = true;
            timedPlatform2.visibleDuration = 2000;
            timedPlatform2.invisibleDuration = 2000;
            timedPlatform2.lastToggle = Date.now() + 1000; // Offset

            createPlatform(0, 0, zOffset - 15, 4, 0.5, 3, 0xf39c12);
            createCheckpoint(0, 0.5, zOffset - 20, 7);
        }

        // ===== STAGE 7: NARROW WALKWAYS =====
        function createStage7(zOffset) {
            createPlatform(0, 0, zOffset, 3, 0.5, 2, 0x95a5a6);
            createPlatform(0, 0, zOffset - 4, 1, 0.5, 4, 0x7f8c8d);
            createPlatform(0, 0, zOffset - 9, 1, 0.5, 4, 0x7f8c8d);
            createPlatform(0, 0, zOffset - 14, 3, 0.5, 2, 0x95a5a6);
            createCheckpoint(0, 0.5, zOffset - 18, 8);
        }

        // ===== STAGE 8: SPEED RUN =====
        function createStage8(zOffset) {
            createPlatform(0, 0, zOffset, 3, 0.5, 2, 0xe91e63);

            for (let i = 1; i <= 8; i++) {
                const platform = createPlatform(0, 0, zOffset - (i * 2.5), 2.5, 0.5, 2, 0xc2185b);
                platform.isCollapsing = true;
                platform.collapseDelay = 500; // 0.5 seconds before collapse
            }

            createPlatform(0, 0, zOffset - 22, 4, 0.5, 3, 0xe91e63);
            createCheckpoint(0, 0.5, zOffset - 26, 9);
        }

        // ===== STAGE 9: BOUNCE PADS =====
        function createStage9(zOffset) {
            createPlatform(0, 0, zOffset, 3, 0.5, 3, 0x00bcd4);

            // Bounce pad 1
            const bouncePad1 = createPlatform(0, 0, zOffset - 5, 2, 0.3, 2, 0xffeb3b);
            bouncePad1.isBouncePad = true;
            bouncePad1.bounceForce = 0.6;

            createPlatform(0, 8, zOffset - 10, 3, 0.5, 3, 0x00bcd4);

            // Bounce pad 2
            const bouncePad2 = createPlatform(0, 8, zOffset - 15, 2, 0.3, 2, 0xffeb3b);
            bouncePad2.isBouncePad = true;
            bouncePad2.bounceForce = 0.6;

            createPlatform(0, 16, zOffset - 20, 4, 0.5, 3, 0x00bcd4);
            createCheckpoint(0, 16.5, zOffset - 24, 10);
        }

        // ===== STAGE 10: MOVING HAZARDS =====
        function createStage10(zOffset) {
            createPlatform(0, 0, zOffset, 4, 0.5, 3, 0x9c27b0);

            const movingPlatform1 = createPlatform(0, 0, zOffset - 6, 3, 0.5, 3, 0x7b1fa2);
            movingPlatform1.isMoving = true;
            movingPlatform1.moveRange = 5;
            movingPlatform1.moveSpeed = 0.03;
            movingPlatform1.moveAxis = 'x';
            movingPlatform1.startX = 0;

            const spinner1 = createPlatform(0, 2, zOffset - 6, 6, 0.3, 0.3, 0x4a148c);
            spinner1.isSpinning = true;
            spinner1.spinSpeed = 0.03;
            obstacles.push(spinner1);

            const movingPlatform2 = createPlatform(0, 0, zOffset - 12, 3, 0.5, 3, 0x7b1fa2);
            movingPlatform2.isMoving = true;
            movingPlatform2.moveRange = 5;
            movingPlatform2.moveSpeed = 0.03;
            movingPlatform2.moveAxis = 'x';
            movingPlatform2.startX = 0;

            const spinner2 = createPlatform(0, 2, zOffset - 12, 6, 0.3, 0.3, 0x4a148c);
            spinner2.isSpinning = true;
            spinner2.spinSpeed = -0.03;
            obstacles.push(spinner2);

            createPlatform(0, 0, zOffset - 18, 4, 0.5, 3, 0x9c27b0);
            createCheckpoint(0, 0.5, zOffset - 23, 11);
        }

        // ===== STAGE 11: HIGH DIFFICULTY =====
        function createStage11(zOffset) {
            createPlatform(0, 0, zOffset, 3, 0.5, 2, 0xff5722);

            // Long jump with moving target
            const movingPlatform1 = createPlatform(0, 0, zOffset - 8, 2, 0.5, 2, 0xe64a19);
            movingPlatform1.isMoving = true;
            movingPlatform1.moveRange = 4;
            movingPlatform1.moveSpeed = 0.04;
            movingPlatform1.moveAxis = 'x';
            movingPlatform1.startX = 0;

            // Narrow path
            createPlatform(0, 0, zOffset - 13, 1, 0.5, 5, 0xbf360c);

            // Fast spinner
            const spinner = createPlatform(0, 1.5, zOffset - 19, 8, 0.3, 0.3, 0x5d4037);
            spinner.isSpinning = true;
            spinner.spinSpeed = 0.04;
            obstacles.push(spinner);

            createPlatform(0, 0, zOffset - 19, 2, 0.5, 2, 0xe64a19);

            createPlatform(0, 0, zOffset - 25, 4, 0.5, 3, 0xff5722);
            createCheckpoint(0, 0.5, zOffset - 30, 12);
        }

        // ===== STAGE 12: FINAL CHALLENGE =====
        function createStage12(zOffset) {
            createPlatform(0, 0, zOffset, 4, 0.5, 3, 0x673ab7);

            // Moving platform with spinner
            const movingPlatform1 = createPlatform(-3, 0, zOffset - 5, 2, 0.5, 2, 0x512da8);
            movingPlatform1.isMoving = true;
            movingPlatform1.moveRange = 6;
            movingPlatform1.moveSpeed = 0.035;
            movingPlatform1.moveAxis = 'x';
            movingPlatform1.startX = -3;

            const spinner1 = createPlatform(0, 2, zOffset - 5, 6, 0.3, 0.3, 0x311b92);
            spinner1.isSpinning = true;
            spinner1.spinSpeed = 0.035;
            obstacles.push(spinner1);

            // Vertical climb
            createPlatform(0, 2, zOffset - 10, 2, 0.5, 2, 0x512da8);
            createPlatform(0, 4, zOffset - 13, 2, 0.5, 2, 0x512da8);

            // Bounce pad
            const bouncePad = createPlatform(0, 4, zOffset - 16, 2, 0.3, 2, 0xffeb3b);
            bouncePad.isBouncePad = true;
            bouncePad.bounceForce = 0.7;

            // Narrow walkway high up
            createPlatform(0, 12, zOffset - 21, 1, 0.5, 6, 0x4527a0);

            // Timed platforms
            const timedPlatform1 = createPlatform(0, 12, zOffset - 28, 2, 0.5, 2, 0x7e57c2);
            timedPlatform1.isTimed = true;
            timedPlatform1.visibleDuration = 1500;
            timedPlatform1.invisibleDuration = 1500;
            timedPlatform1.lastToggle = Date.now();

            // Final platform (Victory!)
            const finalPlatform = createPlatform(0, 12, zOffset - 33, 6, 0.5, 6, 0xffd700);
            finalPlatform.isFinish = true;

            // Victory marker
            const victoryGeometry = new THREE.ConeGeometry(1, 3, 8);
            const victoryMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffd700,
                emissive: 0xffd700,
                emissiveIntensity: 0.7
            });
            const victoryMarker = new THREE.Mesh(victoryGeometry, victoryMaterial);
            victoryMarker.position.set(0, 14.5, zOffset - 33);
            scene.add(victoryMarker);
        }

        // ===== UPDATE MOVING PLATFORMS =====
        function updateMovingPlatforms() {
            platforms.forEach(platform => {
                // Moving platforms
                if (platform.isMoving) {
                    const time = Date.now() * 0.001;
                    if (platform.moveAxis === 'x') {
                        platform.position.x = platform.startX + Math.sin(time * platform.moveSpeed * 50) * platform.moveRange;
                    }
                }

                // Spinning obstacles
                if (platform.isSpinning) {
                    platform.rotation.y += platform.spinSpeed;
                }

                // Timed platforms
                if (platform.isTimed) {
                    const currentTime = Date.now();
                    const elapsed = currentTime - platform.lastToggle;
                    
                    if (platform.visible && elapsed > platform.visibleDuration) {
                        platform.visible = false;
                        platform.material.transparent = true;
                        platform.material.opacity = 0.2;
                        platform.lastToggle = currentTime;
                    } else if (!platform.visible && elapsed > platform.invisibleDuration) {
                        platform.visible = true;
                        platform.material.transparent = false;
                        platform.material.opacity = 1;
                        platform.lastToggle = currentTime;
                    }
                }

                // Collapsing platforms
                if (platform.isCollapsing && platform.stepped) {
                    const elapsed = Date.now() - platform.steppedTime;
                    if (elapsed > platform.collapseDelay) {
                        platform.position.y -= 0.1;
                        if (platform.position.y < -10) {
                            platform.visible = false;
                        }
                    }
                }
            });
        }

        // ===== INPUT HANDLING =====
        function onKeyDown(event) {
            const key = event.key.toLowerCase();
            keys[key] = true;
            
            // Handle jump - can jump anytime when grounded with cooldown
            const now = Date.now();
            if ((key === ' ' || key === 'spacebar') && isGrounded && now - lastJumpTime > 100) {
                playerVelocity.y = jumpForce;
                isGrounded = false;
                lastJumpTime = now;
            }
        }

        function onKeyUp(event) {
            keys[event.key.toLowerCase()] = false;
        }

        // ===== UPDATE FUNCTION =====
        function update() {
            if (gameWon) return;

            // Update input state
            moveForward = keys['w'] || keys['arrowup'];
            moveBackward = keys['s'] || keys['arrowdown'];
            moveLeft = keys['a'] || keys['arrowleft'];
            moveRight = keys['d'] || keys['arrowright'];

            // Calculate movement direction
            const moveDirection = new THREE.Vector3();
            
            if (moveForward) moveDirection.z -= 1;
            if (moveBackward) moveDirection.z += 1;
            if (moveLeft) moveDirection.x -= 1;
            if (moveRight) moveDirection.x += 1;

            // Normalize and apply speed
            if (moveDirection.length() > 0) {
                moveDirection.normalize();
                player.position.x += moveDirection.x * playerSpeed;
                player.position.z += moveDirection.z * playerSpeed;
                
                // Rotate player to face movement direction
                const angle = Math.atan2(moveDirection.x, moveDirection.z);
                player.rotation.y = angle;
            }

            // Apply gravity
            playerVelocity.y += gravity;
            player.position.y += playerVelocity.y;

            // Check collision with platforms
            isGrounded = false;
            let standingOnPlatform = null;

            platforms.forEach(platform => {
                if (!platform.visible) return;
                if (platform.isTimed && !platform.visible) return;

                // Get bounding boxes
                const playerBox = new THREE.Box3().setFromObject(player);
                const platformBox = new THREE.Box3().setFromObject(platform);

                // Check if player is above platform and falling onto it
                const playerBottom = player.position.y - 1; // Player height adjustment
                const platformTop = platform.position.y + platform.geometry.parameters.height / 2;
                const platformBottom = platform.position.y - platform.geometry.parameters.height / 2;

                // Horizontal overlap check
                const horizontalOverlap = 
                    player.position.x > platform.position.x - platform.geometry.parameters.width / 2 - 0.3 &&
                    player.position.x < platform.position.x + platform.geometry.parameters.width / 2 + 0.3 &&
                    player.position.z > platform.position.z - platform.geometry.parameters.depth / 2 - 0.3 &&
                    player.position.z < platform.position.z + platform.geometry.parameters.depth / 2 + 0.3;

                // Check if player is landing on platform from above
                if (horizontalOverlap && playerBottom <= platformTop + 0.1 && playerBottom >= platformBottom && playerVelocity.y <= 0) {
                    player.position.y = platformTop + 1;
                    playerVelocity.y = 0;
                    isGrounded = true;
                    standingOnPlatform = platform;

                    // Check for checkpoint
                    if (platform.isCheckpoint && currentStage < platform.stageNum) {
                        currentStage = platform.stageNum;
                        currentCheckpoint = {
                            x: platform.position.x,
                            y: platform.position.y + 2,
                            z: platform.position.z
                        };
                        updateHUD();
                    }

                    // Check for bounce pad
                    if (platform.isBouncePad) {
                        playerVelocity.y = platform.bounceForce;
                        isGrounded = false;
                    }

                    // Check for collapsing platform
                    if (platform.isCollapsing && !platform.stepped) {
                        platform.stepped = true;
                        platform.steppedTime = Date.now();
                    }

                    // Check for finish
                    if (platform.isFinish) {
                        winGame();
                    }
                }
            });

            // Check collision with obstacles (spinning bars)
            obstacles.forEach(obstacle => {
                const playerBox = new THREE.Box3().setFromObject(player);
                const obstacleBox = new THREE.Box3().setFromObject(obstacle);

                if (playerBox.intersectsBox(obstacleBox)) {
                    respawnPlayer();
                }
            });

            // Fall detection
            if (player.position.y < -10) {
                respawnPlayer();
            }

            // Update camera to follow player smoothly
            const cameraOffset = new THREE.Vector3(0, 5, 10);
            const targetPosition = player.position.clone().add(cameraOffset);
            
            // Smooth camera follow with lerp
            camera.position.lerp(targetPosition, 0.05);
            
            // Smooth camera look-at
            const lookAtTarget = player.position.clone();
            lookAtTarget.y += 2; // Look at player's upper body
            camera.lookAt(lookAtTarget);

            // Animate player
            animatePlayer();

            // Update moving platforms
            updateMovingPlatforms();

            // Update timer
            updateTimer();
        }

        // ===== RESPAWN =====
        function respawnPlayer() {
            player.position.set(currentCheckpoint.x, currentCheckpoint.y, currentCheckpoint.z);
            playerVelocity.set(0, 0, 0);
            deaths++;
            updateHUD();
        }

        // ===== WIN GAME =====
        function winGame() {
            gameWon = true;
            const finalTime = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(finalTime / 60);
            const seconds = finalTime % 60;
            
            document.getElementById('finalTime').textContent = `Time: ${minutes}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('finalDeaths').textContent = `Deaths: ${deaths}`;
            document.getElementById('winScreen').style.display = 'block';
        }

        // ===== RESTART GAME =====
        function restartGame() {
            location.reload();
        }

        // ===== UPDATE HUD =====
        function updateHUD() {
            document.getElementById('stage').textContent = `Stage: ${currentStage}/12`;
            document.getElementById('checkpoint').textContent = `Checkpoint: Stage ${currentStage}`;
            document.getElementById('deaths').textContent = `Deaths: ${deaths}`;
        }

        function updateTimer() {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            document.getElementById('timer').textContent = `Time: ${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        // ===== WINDOW RESIZE =====
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ===== ANIMATION LOOP =====
        function animate() {
            requestAnimationFrame(animate);
            update();
            renderer.render(scene, camera);
        }

        // ===== START GAME =====
        init();
    </script>
</body>
</html>
